<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>2020-05-24-test-maker-analysis-report</title><link href='https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color: #ffffff; --text-color: #333333; --select-text-bg-color: #B5D6FC; --select-text-font-color: auto; --monospace: "Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857143; overflow-x: hidden; background-image: inherit; background-size: inherit; background-attachment: inherit; background-origin: inherit; background-clip: inherit; background-color: inherit; tab-size: 4; background-position: inherit inherit; background-repeat: inherit inherit; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) { 
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font-family: inherit; font-size: inherit; font-style: inherit; font-variant-caps: inherit; font-weight: inherit; font-stretch: inherit; line-height: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.701961); color: rgb(85, 85, 85); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right-width: 0px; background-color: inherit; }
.CodeMirror-linenumber { }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background-image: inherit; background-size: inherit; background-attachment: inherit; background-origin: inherit; background-clip: inherit; background-color: inherit; position: relative !important; background-position: inherit inherit; background-repeat: inherit inherit; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; background-position: 0px 0px; background-repeat: initial initial; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print { 
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid-page; break-before: avoid-page; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid-page; }
  .typora-export #write::after { height: 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background-color: rgb(204, 204, 204); display: block; overflow-x: hidden; background-position: initial initial; background-repeat: initial initial; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-top-left-radius: 10px; border-top-right-radius: 10px; border-bottom-right-radius: 10px; border-bottom-left-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) { 
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background-color: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; background-position: initial initial; background-repeat: initial initial; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; }
a.md-print-anchor { white-space: pre !important; border: none !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; text-shadow: initial !important; background-position: 0px 0px !important; background-repeat: initial initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; margin-top: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom-width: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
svg[id^="mermaidChart"] { line-height: 1em; }


:root {
    --side-bar-bg-color: #fafafa;
    --control-text-color: #777;
}

@include-when-export url(https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext);

html {
    font-size: 16px;
}

body {
    font-family: "Times New Roman","Open Sans","Clear Sans","Helvetica Neue",Helvetica,Arial,sans-serif;
    color: rgb(51, 51, 51);
    line-height: 1.6;
}

#write {
    max-width: 860px;
  	margin: 0 auto;
  	padding: 30px;
    padding-bottom: 100px;
}
#write > ul:first-child,
#write > ol:first-child{
    margin-top: 30px;
}

a {
    color: #4183C4;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 1rem;
    font-weight: bold;
    line-height: 1.4;
    cursor: text;
}
h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}
h1 tt,
h1 code {
    font-size: inherit;
}
h2 tt,
h2 code {
    font-size: inherit;
}
h3 tt,
h3 code {
    font-size: inherit;
}
h4 tt,
h4 code {
    font-size: inherit;
}
h5 tt,
h5 code {
    font-size: inherit;
}
h6 tt,
h6 code {
    font-size: inherit;
}
h1 {
    padding-bottom: .3em;
    font-size: 2.25em;
    line-height: 1.2;
    border-bottom: 1px solid #eee;
}
h2 {
   padding-bottom: .3em;
    font-size: 1.75em;
    line-height: 1.225;
    border-bottom: 1px solid #eee;
}
h3 {
    font-size: 1.5em;
    line-height: 1.43;
}
h4 {
    font-size: 1.25em;
}
h5 {
    font-size: 1em;
}
h6 {
   font-size: 1em;
    color: #777;
}
p,
blockquote,
ul,
ol,
dl,
table{
    margin: 0.8em 0;
}
li>ol,
li>ul {
    margin: 0 0;
}
hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

li p.first {
    display: inline-block;
}
ul,
ol {
    padding-left: 30px;
}
ul:first-child,
ol:first-child {
    margin-top: 0;
}
ul:last-child,
ol:last-child {
    margin-bottom: 0;
}
blockquote {
    border-left: 4px solid #dfe2e5;
    padding: 0 15px;
    color: #777777;
}
blockquote blockquote {
    padding-right: 0;
}
table {
    padding: 0;
    word-break: initial;
}
table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}
table tr:nth-child(2n),
thead {
    background-color: #f8f8f8;
}
table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    margin: 0;
    padding: 6px 13px;
}
table tr td {
    border: 1px solid #dfe2e5;
    margin: 0;
    padding: 6px 13px;
}
table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}
table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

.CodeMirror-lines {
    padding-left: 4px;
}

.code-tooltip {
    box-shadow: 0 1px 1px 0 rgba(0,28,36,.3);
    border-top: 1px solid #eef2f2;
}

.md-fences,
code,
tt {
    border: 1px solid #e7eaed;
    background-color: #f8f8f8;
    border-radius: 3px;
    padding: 0;
    padding: 2px 4px 0px 4px;
    font-size: 0.9em;
}

code {
    background-color: #f3f4f4;
    padding: 0 2px 0 2px;
}

.md-fences {
    margin-bottom: 15px;
    margin-top: 15px;
    padding-top: 8px;
    padding-bottom: 6px;
}


.md-task-list-item > input {
  margin-left: -1.3em;
}

@media print {
    html {
        font-size: 13px;
    }
    table,
    pre {
        page-break-inside: avoid;
    }
    pre {
        word-wrap: break-word;
    }
}

.md-fences {
	background-color: #f8f8f8;
}
#write pre.md-meta-block {
	padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block>.code-tooltip {
	bottom: .375rem;
}

.md-mathjax-midline {
    background: #fafafa;
}

#write>h3.md-focus:before{
	left: -1.5625rem;
	top: .375rem;
}
#write>h4.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h5.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h6.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
.md-image>.md-meta {
    /*border: 1px solid #ddd;*/
    border-radius: 3px;
    padding: 2px 0px 0px 4px;
    font-size: 0.9em;
    color: inherit;
}

.md-tag {
    color: #a7a7a7;
    opacity: 1;
}

.md-toc { 
    margin-top:20px;
    padding-bottom:20px;
}

.sidebar-tabs {
    border-bottom: none;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

/** focus mode */
.on-focus-mode blockquote {
    border-left-color: rgba(85, 85, 85, 0.12);
}

header, .context-menu, .megamenu-content, footer{
    font-family: "Segoe UI", "Arial", sans-serif;
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state{
    visibility: visible;
}

.mac-seamless-mode #typora-sidebar {
    background-color: #fafafa;
    background-color: var(--side-bar-bg-color);
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

#md-notification .btn {
    border: 0;
}

.dropdown-menu .divider {
    border-color: #e5e5e5;
}

.ty-preferences .window-content {
    background-color: #fafafa;
}

.ty-preferences .nav-group-item.active {
    color: white;
    background: #999;
}

 .typora-export li, .typora-export p, .typora-export,  .footnote-line {white-space: normal;} 
</style>
</head>
<body class='typora-export' >
<div  id='write'  class = 'is-mac'><h1><a name="code-analysis" class="md-header-anchor"></a><span>Code analysis</span></h1><h2><a name="test-maker" class="md-header-anchor"></a><span>test-maker </span></h2><h4><a name="version-10" class="md-header-anchor"></a><span>Version 1.0 </span></h4><p><strong><span>By: Administrator</span></strong></p><p><em><span>Date: 2020-05-24</span></em></p><h2><a name="introduction" class="md-header-anchor"></a><span>Introduction</span></h2><p><span>This document contains results of the code analysis of test-maker</span></p><p>&nbsp;</p><h2><a name="configuration" class="md-header-anchor"></a><span>Configuration</span></h2><ul><li><p><span>Quality Profiles</span></p><ul><li><span>Names: Sonar way [Java]; </span></li><li><span>Files: AXJEyxy6NN5stHLmh-tH.json; </span></li></ul></li><li><p><span>Quality Gate</span></p><ul><li><span>Name: Sonar way</span></li><li><span>File: Sonar way.xml</span></li></ul></li></ul><h2><a name="synthesis" class="md-header-anchor"></a><span>Synthesis</span></h2><figure><table><thead><tr><th style='text-align:center;' ><span>Quality Gate</span></th><th style='text-align:center;' ><span>Reliability</span></th><th style='text-align:center;' ><span>Security</span></th><th style='text-align:center;' ><span>Maintainability</span></th><th style='text-align:center;' ><span>Coverage</span></th><th style='text-align:center;' ><span>Duplications</span></th></tr></thead><tbody><tr><td style='text-align:center;' ><span>OK</span></td><td style='text-align:center;' ><span>D</span></td><td style='text-align:center;' ><span>B</span></td><td style='text-align:center;' ><span>A</span></td><td style='text-align:center;' ><span>21.6 %</span></td><td style='text-align:center;' ><span>1.7 %</span></td></tr></tbody></table></figure><h2><a name="metrics" class="md-header-anchor"></a><span>Metrics</span></h2><figure><table><thead><tr><th style='text-align:left;' ><span>\</span></th><th style='text-align:center;' ><span>Cyclomatic Complexity</span></th><th style='text-align:center;' ><span>Cognitive Complexity</span></th><th style='text-align:center;' ><span>Lines of code per file</span></th><th style='text-align:center;' ><span>Coverage</span></th><th style='text-align:center;' ><span>Comment density (%)</span></th><th style='text-align:center;' ><span>Duplication (%)</span></th></tr></thead><tbody><tr><td style='text-align:left;' ><span>Min</span></td><td style='text-align:center;' ><span>0.0</span></td><td style='text-align:center;' ><span>0.0</span></td><td style='text-align:center;' ><span>3.0</span></td><td style='text-align:center;' ><span>0.0</span></td><td style='text-align:center;' ><span>0.0</span></td><td style='text-align:center;' ><span>0.0</span></td></tr><tr><td style='text-align:left;' ><span>Max</span></td><td style='text-align:center;' ><span>2549.0</span></td><td style='text-align:center;' ><span>1324.0</span></td><td style='text-align:center;' ><span>13283.0</span></td><td style='text-align:center;' ><span>100.0</span></td><td style='text-align:center;' ><span>66.7</span></td><td style='text-align:center;' ><span>62.9</span></td></tr></tbody></table></figure><h2><a name="volume" class="md-header-anchor"></a><span>Volume</span></h2><figure><table><thead><tr><th><span>Language</span></th><th><span>Number</span></th></tr></thead><tbody><tr><td><span>Java</span></td><td><span>13283</span></td></tr><tr><td><span>Total</span></td><td><span>13283</span></td></tr></tbody></table></figure><h2><a name="issues-count-by-severity-and-types" class="md-header-anchor"></a><span>Issues count by severity and types</span></h2><figure><table><thead><tr><th><span>Type</span></th><th><span>Severity</span></th><th><span>Number</span></th></tr></thead><tbody><tr><td><span>VULNERABILITY</span></td><td><span>BLOCKER</span></td><td><span>0</span></td></tr><tr><td><span>VULNERABILITY</span></td><td><span>CRITICAL</span></td><td><span>0</span></td></tr><tr><td><span>VULNERABILITY</span></td><td><span>MAJOR</span></td><td><span>0</span></td></tr><tr><td><span>VULNERABILITY</span></td><td><span>MINOR</span></td><td><span>11</span></td></tr><tr><td><span>VULNERABILITY</span></td><td><span>INFO</span></td><td><span>0</span></td></tr><tr><td><span>BUG</span></td><td><span>BLOCKER</span></td><td><span>0</span></td></tr><tr><td><span>BUG</span></td><td><span>CRITICAL</span></td><td><span>1</span></td></tr><tr><td><span>BUG</span></td><td><span>MAJOR</span></td><td><span>21</span></td></tr><tr><td><span>BUG</span></td><td><span>MINOR</span></td><td><span>7</span></td></tr><tr><td><span>BUG</span></td><td><span>INFO</span></td><td><span>0</span></td></tr><tr><td><span>CODE_SMELL</span></td><td><span>BLOCKER</span></td><td><span>5</span></td></tr><tr><td><span>CODE_SMELL</span></td><td><span>CRITICAL</span></td><td><span>51</span></td></tr><tr><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>173</span></td></tr><tr><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>278</span></td></tr><tr><td><span>CODE_SMELL</span></td><td><span>INFO</span></td><td><span>13</span></td></tr><tr><td><span>SECURITY_HOTSPOT</span></td><td><span>BLOCKER</span></td><td><span>0</span></td></tr><tr><td><span>SECURITY_HOTSPOT</span></td><td><span>CRITICAL</span></td><td><span>0</span></td></tr><tr><td><span>SECURITY_HOTSPOT</span></td><td><span>MAJOR</span></td><td><span>0</span></td></tr><tr><td><span>SECURITY_HOTSPOT</span></td><td><span>MINOR</span></td><td><span>0</span></td></tr><tr><td><span>SECURITY_HOTSPOT</span></td><td><span>INFO</span></td><td><span>0</span></td></tr></tbody></table></figure><h2><a name="issues" class="md-header-anchor"></a><span>Issues</span></h2><figure><table><thead><tr><th><span>Name</span></th><th><span>Description</span></th><th><span>Type</span></th><th><span>Severity</span></th><th><span>Number</span></th></tr></thead><tbody><tr><td><span>&quot;Random&quot; objects should be reused</span></td><td><span>Creating a new Random object each time a random value is needed is inefficient and may produce numbers which are not random depending </span><br><span> on the JDK. For better efficiency and randomness, create a single Random, then store, and reuse it. </span><br><span> The Random() constructor tries to set the seed with a distinct value every time. However there is no guarantee that the seed will be </span><br><span> random or even uniformly distributed. Some JDK will use the current time as seed, which makes the generated numbers not random at all. </span><br><span> This rule finds cases where a new Random is created each time a method is invoked and assigned to a local random variable. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> public void doSomethingCommon() { </span><br><span>   Random rand = new Random();  // Noncompliant; new instance created with each invocation </span><br><span>   int rValue = rand.nextInt(); </span><br><span>   //... </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> private Random rand = SecureRandom.getInstanceStrong();  // SecureRandom is preferred to Random </span><br><span>  </span><br><span> public void doSomethingCommon() { </span><br><span>   int rValue = this.rand.nextInt(); </span><br><span>   //... </span><br><span>  </span><br><span> Exceptions </span><br><span> A class which uses a Random in its constructor or in a static main function and nowhere else will be ignored by this </span><br><span> rule. </span><br><span> See </span><br><span>  </span><br><span>    OWASP Top 10 2017 Category A6 - Security </span><br><span>   Misconfiguration  </span><br></td><td><span>BUG</span></td><td><span>CRITICAL</span></td><td><span>1</span></td></tr><tr><td><span>Identical expressions should not be used on both sides of a binary operator</span></td><td><span>Using the same value on either side of a binary operator is almost always a mistake. In the case of logical operators, it is either a copy/paste </span><br><span> error and therefore a bug, or it is simply wasted code, and should be simplified. In the case of bitwise operators and most binary mathematical </span><br><span> operators, having the same value on both sides of an operator yields predictable results, and should be simplified. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> if ( a == a ) { // always true </span><br><span>   doZ(); </span><br><span> } </span><br><span> if ( a != a ) { // always false </span><br><span>   doY(); </span><br><span> } </span><br><span> if ( a == b </span>&amp;&amp;<span> a == b ) { // if the first one is true, the second one is too </span><br><span>   doX(); </span><br><span> } </span><br><span> if ( a == b &amp;#124&amp;#124 a == b ) { // if the first one is true, the second one is too </span><br><span>   doW(); </span><br><span> } </span><br><span>  </span><br><span> int j = 5 / 5; //always 1 </span><br><span> int k = 5 - 5; //always 0 </span><br><span>  </span><br><span> c.equals(c); //always true </span><br><span>  </span><br><span> Exceptions </span><br><span>  </span><br><span>    This rule ignores *, +, and =.  </span><br><span>    The specific case of testing a floating point value against itself is a valid test for NaN and is therefore ignored.  </span><br><span>    Similarly, left-shifting 1 onto 1 is common in the construction of bit masks, and is ignored.  </span><br><span>  </span><br><span>  </span><br><span> float f; </span><br><span> if(f != f) { //test for NaN value </span><br><span>   System.out.println(&quot;f is NaN&quot;); </span><br><span> } </span><br><span>  </span><br><span> int i = 1 </span>&lt;&lt;<span> 1; // Compliant </span><br><span> int j = a </span>&lt;&lt;<span> a; // Noncompliant </span><br><span>  </span><br><span> See </span><br><span>  </span><br><span>    CERT, MSC12-C. - Detect and remove code that has no effect or is never </span><br><span>   executed  </span><br><span>    S1656 - Implements a check on =.  </span><br></td><td><span>BUG</span></td><td><span>MAJOR</span></td><td><span>1</span></td></tr><tr><td><span>Null pointers should not be dereferenced</span></td><td><span>A reference to null should never be dereferenced/accessed. Doing so will cause a NullPointerException to be thrown. At </span><br><span> best, such an exception will cause abrupt program termination. At worst, it could expose debugging information that would be useful to an attacker, or </span><br><span> it could allow an attacker to bypass security measures. </span><br><span> Note that when they are present, this rule takes advantage of @CheckForNull and @Nonnull annotations defined in JSR-305 to understand which values are and are not nullable except when @Nonnull is used </span><br><span> on the parameter to equals, which by contract should always work with null. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> @CheckForNull </span><br><span> String getName(){...} </span><br><span>  </span><br><span> public boolean isNameEmpty() { </span><br><span>   return getName().length() == 0; // Noncompliant; the result of getName() could be null, but isn&#39;t null-checked </span><br><span> } </span><br><span>  </span><br><span>  </span><br><span> Connection conn = null; </span><br><span> Statement stmt = null; </span><br><span> try{ </span><br><span>   conn = DriverManager.getConnection(DB_URL,USER,PASS); </span><br><span>   stmt = conn.createStatement(); </span><br><span>   // ... </span><br><span>  </span><br><span> }catch(Exception e){ </span><br><span>   e.printStackTrace(); </span><br><span> }finally{ </span><br><span>   stmt.close();   // Noncompliant; stmt could be null if an exception was thrown in the try{} block </span><br><span>   conn.close();  // Noncompliant; conn could be null if an exception was thrown </span><br><span> } </span><br><span>  </span><br><span>  </span><br><span> private void merge(@Nonnull Color firstColor, @Nonnull Color secondColor){...} </span><br><span>  </span><br><span> public  void append(@CheckForNull Color color) { </span><br><span>     merge(currentColor, color);  // Noncompliant; color should be null-checked because merge(...) doesn&#39;t accept nullable parameters </span><br><span> } </span><br><span>  </span><br><span>  </span><br><span> void paint(Color color) { </span><br><span>   if(color == null) { </span><br><span>     System.out.println(&quot;Unable to apply color &quot; + color.toString());  // Noncompliant; NullPointerException will be thrown </span><br><span>     return; </span><br><span>   } </span><br><span>   ... </span><br><span> } </span><br><span>  </span><br><span> See </span><br><span>  </span><br><span>    MITRE, CWE-476 - NULL Pointer Dereference  </span><br><span>    CERT, EXP34-C. - Do not dereference null pointers  </span><br><span>    CERT, EXP01-J. - Do not use a null in a case where an object is required </span><br><span>    </span><br></td><td><span>BUG</span></td><td><span>MAJOR</span></td><td><span>15</span></td></tr><tr><td><span>Conditionally executed code should be reachable</span></td><td><span>Conditional expressions which are always true or false can lead to dead code. Such code is always buggy and should never </span><br><span> be used in production. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> a = false; </span><br><span> if (a) { // Noncompliant </span><br><span>   doSomething(); // never executed </span><br><span> } </span><br><span>  </span><br><span> if (!a &amp;#124&amp;#124 b) { // Noncompliant; &quot;!a&quot; is always &quot;true&quot;, &quot;b&quot; is never evaluated </span><br><span>   doSomething(); </span><br><span> } else { </span><br><span>   doSomethingElse(); // never executed </span><br><span> } </span><br><span>  </span><br><span> Exceptions </span><br><span> This rule will not raise an issue in either of these cases: </span><br><span>  </span><br><span>    When the condition is a single final boolean  </span><br><span>  </span><br><span>  </span><br><span> final boolean debug = false; </span><br><span> //... </span><br><span> if (debug) { </span><br><span>   // Print something </span><br><span> } </span><br><span>  </span><br><span>  </span><br><span>    When the condition is literally true or false.  </span><br><span>  </span><br><span>  </span><br><span> if (true) { </span><br><span>   // do something </span><br><span> } </span><br><span>  </span><br><span> In these cases it is obvious the code is as intended. </span><br><span> See </span><br><span>  </span><br><span>    MITRE, CWE-570 - Expression is Always False  </span><br><span>    MITRE, CWE-571 - Expression is Always True  </span><br><span>    CERT, MSC12-C. - Detect and remove code that has no effect or is never </span><br><span>   executed  </span><br></td><td><span>BUG</span></td><td><span>MAJOR</span></td><td><span>3</span></td></tr><tr><td><span>Non-thread-safe fields should not be static</span></td><td><span>Not all classes in the standard Java library were written to be thread-safe. Using them in a multi-threaded manner is highly likely to cause data </span><br><span> problems or exceptions at runtime. </span><br><span> This rule raises an issue when an instance of Calendar, DateFormat, javax.xml.xpath.XPath, or </span><br><span> javax.xml.validation.SchemaFactory is marked static. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> public class MyClass { </span><br><span>   private static SimpleDateFormat format = new SimpleDateFormat(&quot;HH-mm-ss&quot;);  // Noncompliant </span><br><span>   private static Calendar calendar = Calendar.getInstance();  // Noncompliant </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> public class MyClass { </span><br><span>   private SimpleDateFormat format = new SimpleDateFormat(&quot;HH-mm-ss&quot;); </span><br><span>   private Calendar calendar = Calendar.getInstance(); </span><br></td><td><span>BUG</span></td><td><span>MAJOR</span></td><td><span>2</span></td></tr><tr><td><span>Math operands should be cast before assignment</span></td><td><span>When arithmetic is performed on integers, the result will always be an integer. You can assign that result to a long, </span><br><span> double, or float with automatic type conversion, but having started as an int or long, the result </span><br><span> will likely not be what you expect.  </span><br><span> For instance, if the result of int division is assigned to a floating-point variable, precision will have been lost before the </span><br><span> assignment. Likewise, if the result of multiplication is assigned to a long, it may have already overflowed before the assignment. </span><br><span> In either case, the result will not be what was expected. Instead, at least one operand should be cast or promoted to the final type before the </span><br><span> operation takes place. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> float twoThirds = 2/3; // Noncompliant; int division. Yields 0.0 </span><br><span> long millisInYear = 1_000</span><em><span>3_600</span></em><span>24*365; // Noncompliant; int multiplication. Yields 1471228928 &lt;br /&gt; long bigNum = Integer.MAX_VALUE + 2; // Noncompliant. Yields -2147483647 &lt;br /&gt; long bigNegNum =  Integer.MIN_VALUE-1; //Noncompliant, gives a positive result instead of a negative one. &lt;br /&gt; Date myDate = new Date(seconds * 1_000); //Noncompliant, won&#39;t produce the expected result if seconds </span>&gt;<span> 2_147_483 </span><br><span> ... </span><br><span> public long compute(int factor){ </span><br><span>   return factor * 10_000;  //Noncompliant, won&#39;t produce the expected result if factor </span>&gt;<span> 214_748 </span><br><span> } </span><br><span>  </span><br><span> public float compute2(long factor){ </span><br><span>   return factor / 123;  //Noncompliant, will be rounded to closest long integer </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> float twoThirds = 2f/3; // 2 promoted to float. Yields 0.6666667 </span><br><span> long millisInYear = 1_000L</span><em><span>3_600</span></em><span>24*365; // 1000 promoted to long. Yields 31_536_000_000 &lt;br /&gt; long bigNum = Integer.MAX_VALUE + 2L; // 2 promoted to long. Yields 2_147_483_649 &lt;br /&gt; long bigNegNum =  Integer.MIN_VALUE-1L; // Yields -2_147_483_649 &lt;br /&gt; Date myDate = new Date(seconds * 1_000L); </span><br><span> ... </span><br><span> public long compute(int factor){ </span><br><span>   return factor * 10_000L; </span><br><span> } </span><br><span>  </span><br><span> public float compute2(long factor){ </span><br><span>   return factor / 123f; </span><br><span> } </span><br><span>  </span><br><span> or </span><br><span>  </span><br><span> float twoThirds = (float)2/3; // 2 cast to float </span><br><span> long millisInYear = (long)1_000</span><em><span>3_600</span></em><span>24*365; // 1_000 cast to long </span><br><span> long bigNum = (long)Integer.MAX_VALUE + 2; </span><br><span> long bigNegNum =  (long)Integer.MIN_VALUE-1; </span><br><span> Date myDate = new Date((long)seconds * 1_000); </span><br><span> ... </span><br><span> public long compute(long factor){ </span><br><span>   return factor * 10_000; </span><br><span> } </span><br><span>  </span><br><span> public float compute2(float factor){ </span><br><span>   return factor / 123; </span><br><span> } </span><br><span>  </span><br><span> See </span><br><span>  </span><br><span>    MITRE, CWE-190 - Integer Overflow or Wraparound  </span><br><span>    CERT, NUM50-J. - Convert integers to floating point for floating-point </span><br><span>   operations  </span><br><span>    CERT, INT18-C. - Evaluate integer expressions in a larger size before </span><br><span>   comparing or assigning to that size  </span><br><span>    SANS Top 25 - Risky Resource Management  </span><br></td><td><span>BUG</span></td><td><span>MINOR</span></td><td><span>6</span></td></tr><tr><td><span>&quot;@NonNull&quot; values should not be set to null</span></td><td><span>Fields, parameters and return values marked @NotNull, @NonNull, or @Nonnull are assumed to have non-null </span><br><span> values and are not typically null-checked before use. Therefore setting one of these values to null, or failing to set such a class field </span><br><span> in a constructor, could cause NullPointerExceptions at runtime. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> public class MainClass { </span><br><span>  </span><br><span>   @Nonnull </span><br><span>   private String primary; </span><br><span>   private String secondary; </span><br><span>  </span><br><span>   public MainClass(String color) { </span><br><span>     if (color != null) { </span><br><span>       secondary = null; </span><br><span>     } </span><br><span>     primary = color;  // Noncompliant; &quot;primary&quot; is Nonnull but could be set to null here </span><br><span>   } </span><br><span>  </span><br><span>   public MainClass() { // Noncompliant; &quot;primary&quot; Nonnull&quot; but is not initialized </span><br><span>   } </span><br><span>  </span><br><span>   @Nonnull </span><br><span>   public String indirectMix() { </span><br><span>     String mix = null; </span><br><span>     return mix;  // Noncompliant; return value is Nonnull, but null is returned.}} </span><br><span>   } </span><br><span>  </span><br><span> See </span><br><span>  </span><br><span>    MITRE CWE-476 - NULL Pointer Dereference  </span><br><span>    CERT, EXP01-J. - Do not use a null in a case where an object is required </span><br><span>    </span><br></td><td><span>BUG</span></td><td><span>MINOR</span></td><td><span>1</span></td></tr><tr><td><span>Child class fields should not shadow parent class fields</span></td><td><span>Having a variable with the same name in two unrelated classes is fine, but do the same thing within a class hierarchy and you&#39;ll get confusion at </span><br><span> best, chaos at worst.  </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> public class Fruit { </span><br><span>   protected Season ripe; </span><br><span>   protected Color flesh; </span><br><span>  </span><br><span>   // ... </span><br><span> } </span><br><span>  </span><br><span> public class Raspberry extends Fruit { </span><br><span>   private boolean ripe;  // Noncompliant </span><br><span>   private static Color FLESH; // Noncompliant </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> public class Fruit { </span><br><span>   protected Season ripe; </span><br><span>   protected Color flesh; </span><br><span>  </span><br><span>   // ... </span><br><span> } </span><br><span>  </span><br><span> public class Raspberry extends Fruit { </span><br><span>   private boolean ripened; </span><br><span>   private static Color FLESH_COLOR; </span><br><span>  </span><br><span> } </span><br><span>  </span><br><span> Exceptions </span><br><span> This rule ignores same-name fields that are static in both the parent and child classes. This rule ignores private parent </span><br><span> class fields, but in all other such cases, the child class field should be renamed. </span><br><span>  </span><br><span> public class Fruit { </span><br><span>   private Season ripe; </span><br><span>   // ... </span><br><span> } </span><br><span>  </span><br><span> public class Raspberry extends Fruit { </span><br><span>   private Season ripe;  // Compliant as parent field &#39;ripe&#39; is anyway not visible from Raspberry </span><br><span>   // ... </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>BLOCKER</span></td><td><span>2</span></td></tr><tr><td><span>Methods returns should not be invariant</span></td><td><span>When a method is designed to return an invariant value, it may be poor design, but it shouldn&#39;t adversely affect the outcome of your program. </span><br><span> However, when it happens on all paths through the logic, it is surely a bug. </span><br><span> This rule raises an issue when a method contains several return statements that all return the same value. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> int foo(int a) { </span><br><span>   int b = 12; </span><br><span>   if (a == 1) { </span><br><span>     return b; </span><br><span>   } </span><br><span>   return b;  // Noncompliant </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>BLOCKER</span></td><td><span>3</span></td></tr><tr><td><span>Constant names should comply with a naming convention</span></td><td><span>Shared coding conventions allow teams to collaborate efficiently. This rule checks that all constant names match a provided regular expression. </span><br><span> Noncompliant Code Example </span><br><span> With the default regular expression ^</span>[<span>A-Z</span>][A-Z0-9]<em><span>(_[A-Z0-9]+)</span></em><span>$: </span><br><span>  </span><br><span> public class MyClass { </span><br><span>   public static final int first = 1; </span><br><span> } </span><br><span>  </span><br><span> public enum MyEnum { </span><br><span>   first; </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> public class MyClass { </span><br><span>   public static final int FIRST = 1; </span><br><span> } </span><br><span>  </span><br><span> public enum MyEnum { </span><br><span>   FIRST; </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>CRITICAL</span></td><td><span>3</span></td></tr><tr><td><span>Methods should not be empty</span></td><td><span>There are several reasons for a method not to have a method body: </span><br><span>  </span><br><span>    It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production.  </span><br><span>    It is not yet, or never will be, supported. In this case an UnsupportedOperationException should be thrown.  </span><br><span>    The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override.  </span><br><span>  </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> public void doSomething() { </span><br><span> } </span><br><span>  </span><br><span> public void doSomethingElse() { </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> @Override </span><br><span> public void doSomething() { </span><br><span>   // Do nothing because of X and Y. </span><br><span> } </span><br><span>  </span><br><span> @Override </span><br><span> public void doSomethingElse() { </span><br><span>   throw new UnsupportedOperationException(); </span><br><span> } </span><br><span>  </span><br><span> Exceptions </span><br><span> Default (no-argument) constructors are ignored when there are other constructors in the class, as are empty methods in abstract classes. </span><br><span>  </span><br><span> public abstract class Animal { </span><br><span>   void speak() {  // default implementation ignored </span><br><span>   } </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>CRITICAL</span></td><td><span>23</span></td></tr><tr><td><span>String literals should not be duplicated</span></td><td><span>Duplicated string literals make the process of refactoring error-prone, since you must be sure to update all occurrences. </span><br><span> On the other hand, constants can be referenced from many places, but only need to be updated in a single place. </span><br><span> Noncompliant Code Example </span><br><span> With the default threshold of 3: </span><br><span>  </span><br><span> public void run() { </span><br><span>   prepare(&quot;action1&quot;);                              // Noncompliant - &quot;action1&quot; is duplicated 3 times </span><br><span>   execute(&quot;action1&quot;); </span><br><span>   release(&quot;action1&quot;); </span><br><span> } </span><br><span>  </span><br><span> @SuppressWarning(&quot;all&quot;)                            // Compliant - annotations are excluded </span><br><span> private void method1() { /* ... </span><em><span>/ } </span><br><span> @SuppressWarning(&quot;all&quot;) </span><br><span> private void method2() { /</span></em><span> ... */ } </span><br><span>  </span><br><span> public String method3(String a) { </span><br><span>   System.out.println(&quot;&#39;&quot; + a + &quot;&#39;&quot;);               // Compliant - literal &quot;&#39;&quot; has less than 5 characters and is excluded </span><br><span>   return &quot;&quot;;                                       // Compliant - literal &quot;&quot; has less than 5 characters and is excluded </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> private static final String ACTION_1 = &quot;action1&quot;;  // Compliant </span><br><span>  </span><br><span> public void run() { </span><br><span>   prepare(ACTION_1);                               // Compliant </span><br><span>   execute(ACTION_1); </span><br><span>   release(ACTION_1); </span><br><span> } </span><br><span>  </span><br><span> Exceptions </span><br><span> To prevent generating some false-positives, literals having less than 5 characters are excluded.</span></td><td><span>CODE_SMELL</span></td><td><span>CRITICAL</span></td><td><span>14</span></td></tr><tr><td><span>Constants should not be defined in interfaces</span></td><td><span>According to Joshua Bloch, author of &quot;Effective Java&quot;: </span><br><span>  </span><br><span>   The constant interface pattern is a poor use of interfaces.  </span><br><span>   That a class uses some constants internally is an implementation detail. </span><br><span>   Implementing a constant interface causes this implementation detail to leak into the class&#39;s exported API. It is of no consequence to the users </span><br><span>   of a class that the class implements a constant interface. In fact, it may even confuse them. Worse, it represents a commitment: if in a future </span><br><span>   release the class is modified so that it no longer needs to use the constants, it still must implement the interface to ensure binary compatibility. </span><br><span>   If a nonfinal class implements a constant interface, </span><br><span>   all of its subclasses will have their namespaces polluted by the constants in the interface. </span><br><span>  </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> interface Status {                      // Noncompliant </span><br><span>    int OPEN = 1; </span><br><span>    int CLOSED = 2; </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> public enum Status {                    // Compliant </span><br><span>   OPEN, </span><br><span>   CLOSED; </span><br><span> } </span><br><span>  </span><br><span> or </span><br><span>  </span><br><span> public final class Status {             // Compliant </span><br><span>    public static final int OPEN = 1; </span><br><span>    public static final int CLOSED = 2; </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>CRITICAL</span></td><td><span>1</span></td></tr><tr><td><span>Fields in a &quot;Serializable&quot; class should either be transient or serializable</span></td><td><span>Fields in a Serializable class must themselves be either Serializable or transient even if the class is </span><br><span> never explicitly serialized or deserialized. For instance, under load, most J2EE application frameworks flush objects to disk, and an allegedly </span><br><span> Serializable object with non-transient, non-serializable data members could cause program crashes, and open the door to attackers. In </span><br><span> general a Serializable class is expected to fulfil its contract and not have an unexpected behaviour when an instance is serialized.  </span><br><span> This rule raises an issue on non-Serializable fields, and on collection fields when they are not private (because they </span><br><span> could be assigned non-Serializable values externally), and when they are assigned non-Serializable types within the </span><br><span> class. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> public class Address { </span><br><span>   //... </span><br><span> } </span><br><span>  </span><br><span> public class Person implements Serializable { </span><br><span>   private static final long serialVersionUID = 1905122041950251207L; </span><br><span>  </span><br><span>   private String name; </span><br><span>   private Address address;  // Noncompliant; Address isn&#39;t serializable </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> public class Address implements Serializable { </span><br><span>   private static final long serialVersionUID = 2405172041950251807L; </span><br><span> } </span><br><span>  </span><br><span> public class Person implements Serializable { </span><br><span>   private static final long serialVersionUID = 1905122041950251207L; </span><br><span>  </span><br><span>   private String name; </span><br><span>   private Address address; </span><br><span> } </span><br><span>  </span><br><span> Exceptions </span><br><span> The alternative to making all members serializable or transient is to implement special methods which take on the </span><br><span> responsibility of properly serializing and de-serializing the object. This rule ignores classes which implement the following methods: </span><br><span>  </span><br><span>  private void writeObject(java.io.ObjectOutputStream out) </span><br><span>      throws IOException </span><br><span>  private void readObject(java.io.ObjectInputStream in) </span><br><span>      throws IOException, ClassNotFoundException; </span><br><span>  </span><br><span> See </span><br><span>  </span><br><span>    MITRE, CWE-594 - Saving Unserializable Objects to Disk  </span><br><span>    Oracle Java 6, Serializable  </span><br><span>    Oracle Java 7, Serializable  </span><br></td><td><span>CODE_SMELL</span></td><td><span>CRITICAL</span></td><td><span>3</span></td></tr><tr><td><span>&quot;static&quot; base class members should not be accessed via derived types</span></td><td><span>In the interest of code clarity, static members of a base class should never be accessed using a derived type&#39;s name. </span><br><span> Doing so is confusing and could create the illusion that two different static members exist. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> class Parent { </span><br><span>   public static int counter; </span><br><span> } </span><br><span>  </span><br><span> class Child extends Parent { </span><br><span>   public Child() { </span><br><span>     Child.counter++;  // Noncompliant </span><br><span>   } </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> class Parent { </span><br><span>   public static int counter; </span><br><span> } </span><br><span>  </span><br><span> class Child extends Parent { </span><br><span>   public Child() { </span><br><span>     Parent.counter++; </span><br><span>   } </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>CRITICAL</span></td><td><span>1</span></td></tr><tr><td><span>Cognitive Complexity of methods should not be too high</span></td><td><span>Cognitive Complexity is a measure of how hard the control flow of a method is to understand. Methods with high Cognitive Complexity will be </span><br><span> difficult to maintain. </span><br><span> See </span><br><span>  </span><br><span>    Cognitive Complexity  </span><br></td><td><span>CODE_SMELL</span></td><td><span>CRITICAL</span></td><td><span>6</span></td></tr><tr><td><span>Track uses of &quot;TODO&quot; tags</span></td><td><span>TODO tags are commonly used to mark places where some more code is required, but which the developer wants to implement later. </span><br><span> Sometimes the developer will not have the time or will simply forget to get back to that tag. </span><br><span> This rule is meant to track those tags and to ensure that they do not go unnoticed. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> void doSomething() { </span><br><span>   // TODO </span><br><span> } </span><br><span>  </span><br><span> See </span><br><span>  </span><br><span>    MITRE, CWE-546 - Suspicious Comment  </span><br></td><td><span>CODE_SMELL</span></td><td><span>INFO</span></td><td><span>13</span></td></tr><tr><td><span>Source files should not have any duplicated blocks</span></td><td><span>An issue is created on a file as soon as there is at least one block of duplicated code on this file</span></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>17</span></td></tr><tr><td><span>Standard outputs should not be used directly to log anything</span></td><td><span>When logging a message there are several important requirements which must be fulfilled: </span><br><span>  </span><br><span>    The user must be able to easily retrieve the logs  </span><br><span>    The format of all logged message must be uniform to allow the user to easily read the log  </span><br><span>    Logged data must actually be recorded  </span><br><span>    Sensitive data must only be logged securely  </span><br><span>  </span><br><span> If a program directly writes to the standard outputs, there is absolutely no way to comply with those requirements. That&#39;s why defining and using a </span><br><span> dedicated logger is highly recommended. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> System.out.println(&quot;My Message&quot;);  // Noncompliant </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> logger.log(&quot;My Message&quot;); </span><br><span>  </span><br><span> See </span><br><span>  </span><br><span>    CERT, ERR02-J. - Prevent exceptions while logging data  </span><br></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>2</span></td></tr><tr><td><span>Collapsible &quot;if&quot; statements should be merged</span></td><td><span>Merging collapsible if statements increases the code&#39;s readability. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> if (file != null) { </span><br><span>   if (file.isFile() &amp;#124&amp;#124 file.isDirectory()) { </span><br><span>     /* ... </span><em><span>/ </span><br><span>   } </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> if (file != null </span>&amp;&amp;<span> isFileOrDirectory(file)) { </span><br><span>   /</span></em><span> ... */ </span><br><span> } </span><br><span>  </span><br><span> private static boolean isFileOrDirectory(File file) { </span><br><span>   return file.isFile() &amp;#124&amp;#124 file.isDirectory(); </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>11</span></td></tr><tr><td><span>Unused &quot;private&quot; fields should be removed</span></td><td><span>If a private field is declared but not used in the program, it can be considered dead code and should therefore be removed. This will </span><br><span> improve maintainability because developers will not wonder what the variable is used for. </span><br><span> Note that this rule does not take reflection into account, which means that issues will be raised on private fields that are only </span><br><span> accessed using the reflection API. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> public class MyClass { </span><br><span>   private int foo = 42; </span><br><span>  </span><br><span>   public int compute(int a) { </span><br><span>     return a * 42; </span><br><span>   } </span><br><span>  </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> public class MyClass { </span><br><span>   public int compute(int a) { </span><br><span>     return a * 42; </span><br><span>   } </span><br><span> } </span><br><span>  </span><br><span> Exceptions </span><br><span> The Java serialization runtime associates with each serializable class a version number, called serialVersionUID, which is used during </span><br><span> deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to </span><br><span> serialization. </span><br><span> A serializable class can declare its own serialVersionUID explicitly by declaring a field named serialVersionUID that </span><br><span> must be static, final, and of type long. By definition those serialVersionUID fields should not be reported by this rule: </span><br><span>  </span><br><span> public class MyClass implements java.io.Serializable { </span><br><span>   private static final long serialVersionUID = 42L; </span><br><span> } </span><br><span>  </span><br><span> Moreover, this rule doesn&#39;t raise any issue on annotated fields.</span></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>9</span></td></tr><tr><td><span>Nested blocks of code should not be left empty</span></td><td><span>Most of the time a block of code is empty when a piece of code is really missing. So such empty block must be either filled or removed. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> for (int i = 0; i </span>&lt;<span> 42; i++){}  // Empty on purpose or missing piece of code ? </span><br><span>  </span><br><span> Exceptions </span><br><span> When a block contains a comment, this block is not considered to be empty unless it is a synchronized block. synchronized </span><br><span> blocks are still considered empty even with comments because they can still affect program flow.</span></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>1</span></td></tr><tr><td><span>Inheritance tree of classes should not be too deep</span></td><td><span>Inheritance is certainly one of the most valuable concepts in object-oriented programming. It&#39;s a way to compartmentalize and reuse code by </span><br><span> creating collections of attributes and behaviors called classes which can be based on previously created classes. But abusing this concept by creating </span><br><span> a deep inheritance tree can lead to very complex and unmaintainable source code. Most of the time a too deep inheritance tree is due to bad object </span><br><span> oriented design which has led to systematically use &#39;inheritance&#39; when for instance &#39;composition&#39; would suit better. </span><br><span> This rule raises an issue when the inheritance tree, starting from Object has a greater depth than is allowed.</span></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>1</span></td></tr><tr><td><span>Local variables should not shadow class fields</span></td><td><span>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of </span><br><span> code. Further, it could lead maintainers to introduce bugs because they think they&#39;re using one variable but are really using another. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> class Foo { </span><br><span>   public int myField; </span><br><span>  </span><br><span>   public void doSomething() { </span><br><span>     int myField = 0; </span><br><span>     ... </span><br><span>   } </span><br><span> } </span><br><span>  </span><br><span> See </span><br><span>  </span><br><span>    CERT, DCL01-C. - Do not reuse </span><br><span>   variable names in subscopes  </span><br><span>    CERT, DCL51-J. - Do </span><br><span>   not shadow or obscure identifiers in subscopes  </span><br></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>4</span></td></tr><tr><td><span>Utility classes should not have public constructors</span></td><td><span>Utility classes, which are collections of static members, are not meant to be instantiated. Even abstract utility classes, which can </span><br><span> be extended, should not have public constructors. </span><br><span> Java adds an implicit public constructor to every class which does not define at least one explicitly. Hence, at least one non-public constructor </span><br><span> should be defined. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> class StringUtils { // Noncompliant </span><br><span>  </span><br><span>   public static String concatenate(String s1, String s2) { </span><br><span>     return s1 + s2; </span><br><span>   } </span><br><span>  </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> class StringUtils { // Compliant </span><br><span>  </span><br><span>   private StringUtils() { </span><br><span>     throw new IllegalStateException(&quot;Utility class&quot;); </span><br><span>   } </span><br><span>  </span><br><span>   public static String concatenate(String s1, String s2) { </span><br><span>     return s1 + s2; </span><br><span>   } </span><br><span>  </span><br><span> } </span><br><span>  </span><br><span> Exceptions </span><br><span> When class contains public static void main(String[] args) method it is not considered as utility class and will be ignored by this </span><br><span> rule.</span></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>8</span></td></tr><tr><td><span>Labels should not be used</span></td><td><span>Labels are not commonly used in Java, and many developers do not understand how they work. Moreover, their usage makes the control flow harder to </span><br><span> follow, which reduces the code&#39;s readability. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> int matrix</span>[][]<span> = { </span><br><span>   {1, 2, 3}, </span><br><span>   {4, 5, 6}, </span><br><span>   {7, 8, 9} </span><br><span> }; </span><br><span>  </span><br><span> outer: for (int row = 0; row </span>&lt;<span> matrix.length; row++) {   // Non-Compliant </span><br><span>   for (int col = 0; col </span>&lt;<span> matrix[row].length; col++) { </span><br><span>     if (col == row) { </span><br><span>       continue outer; </span><br><span>     } </span><br><span>     System.out.println(matrix</span>[<span>row</span>][col]<span>);                // Prints the elements under the diagonal, i.e. 4, 7 and 8 </span><br><span>   } </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> for (int row = 1; row </span>&lt;<span> matrix.length; row++) {          // Compliant </span><br><span>   for (int col = 0; col </span>&lt;<span> row; col++) { </span><br><span>     System.out.println(matrix</span>[<span>row</span>][col]<span>);                // Also prints 4, 7 and 8 </span><br><span>   } </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>2</span></td></tr><tr><td><span>Generic exceptions should never be thrown</span></td><td><span>Using such generic exceptions as Error, RuntimeException, Throwable, and Exception prevents </span><br><span> calling methods from handling true, system-generated exceptions differently than application-generated errors.  </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> public void foo(String bar) throws Throwable {  // Noncompliant </span><br><span>   throw new RuntimeException(&quot;My Message&quot;);     // Noncompliant </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> public void foo(String bar) { </span><br><span>   throw new MyOwnRuntimeException(&quot;My Message&quot;); </span><br><span> } </span><br><span>  </span><br><span> Exceptions </span><br><span> Generic exceptions in the signatures of overriding methods are ignored, because overriding method has to follow signature of the throw declaration </span><br><span> in the superclass. The issue will be raised on superclass declaration of the method (or won&#39;t be raised at all if superclass is not part of the </span><br><span> analysis). </span><br><span>  </span><br><span> @Override </span><br><span> public void myMethod() throws Exception {...} </span><br><span>  </span><br><span> Generic exceptions are also ignored in the signatures of methods that make calls to methods that throw generic exceptions. </span><br><span>  </span><br><span> public void myOtherMethod throws Exception { </span><br><span>   doTheThing();  // this method throws Exception </span><br><span> } </span><br><span>  </span><br><span> See </span><br><span>  </span><br><span>    MITRE, CWE-397 - Declaration of Throws for Generic Exception  </span><br><span>    CERT, ERR07-J. - Do not throw RuntimeException, Exception, or Throwable </span><br><span>    </span><br></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>20</span></td></tr><tr><td><span>Assignments should not be made from within sub-expressions</span></td><td><span>Assignments within sub-expressions are hard to spot and therefore make the code less readable. Ideally, sub-expressions should not have </span><br><span> side-effects. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> if ((str = cont.substring(pos1, pos2)).isEmpty()) {  // Noncompliant </span><br><span>   //... </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> str = cont.substring(pos1, pos2); </span><br><span> if (str.isEmpty()) { </span><br><span>   //... </span><br><span>  </span><br><span> Exceptions </span><br><span> Assignments in while statement conditions, and assignments enclosed in relational expressions are ignored. </span><br><span>  </span><br><span> BufferedReader br = new BufferedReader(/* ... */); </span><br><span> String line; </span><br><span> while ((line = br.readLine()) != null) {...} </span><br><span>  </span><br><span> Chained assignments, including compound assignments, are ignored. </span><br><span>  </span><br><span> int i = j = 0; </span><br><span> int k = (j += 1); </span><br><span> result = (bresult = new byte[len]); </span><br><span>  </span><br><span> See </span><br><span>  </span><br><span>    MITRE, CWE-481 - Assigning instead of Comparing  </span><br><span>    CERT, EXP45-C. - Do not perform assignments in selection statements  </span><br><span>    CERT, EXP51-J. - Do not perform assignments in conditional expressions </span><br><span>    </span><br></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>1</span></td></tr><tr><td><span>Track uses of &quot;FIXME&quot; tags</span></td><td><span>FIXME tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with later. </span><br><span> Sometimes the developer will not have the time or will simply forget to get back to that tag. </span><br><span> This rule is meant to track those tags and to ensure that they do not go unnoticed. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> int divide(int numerator, int denominator) { </span><br><span>   return numerator / denominator;              // FIXME denominator value might be  0 </span><br><span> } </span><br><span>  </span><br><span> See </span><br><span>  </span><br><span>    MITRE, CWE-546 - Suspicious Comment  </span><br></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>1</span></td></tr><tr><td><span>Unused &quot;private&quot; methods should be removed</span></td><td><span>private methods that are never executed are dead code: unnecessary, inoperative code that should be removed. Cleaning out dead code </span><br><span> decreases the size of the maintained codebase, making it easier to understand the program and preventing bugs from being introduced. </span><br><span> Note that this rule does not take reflection into account, which means that issues will be raised on private methods that are only </span><br><span> accessed using the reflection API. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> public class Foo implements Serializable </span><br><span> { </span><br><span>   private Foo(){}     //Compliant, private empty constructor intentionally used to prevent any direct instantiation of a class. </span><br><span>   public static void doSomething(){ </span><br><span>     Foo foo = new Foo(); </span><br><span>     ... </span><br><span>   } </span><br><span>   private void unusedPrivateMethod(){...} </span><br><span>   private void writeObject(ObjectOutputStream s){...}  //Compliant, relates to the java serialization mechanism </span><br><span>   private void readObject(ObjectInputStream in){...}  //Compliant, relates to the java serialization mechanism </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> public class Foo implements Serializable </span><br><span> { </span><br><span>   private Foo(){}     //Compliant, private empty constructor intentionally used to prevent any direct instantiation of a class. </span><br><span>   public static void doSomething(){ </span><br><span>     Foo foo = new Foo(); </span><br><span>     ... </span><br><span>   } </span><br><span>  </span><br><span>   private void writeObject(ObjectOutputStream s){...}  //Compliant, relates to the java serialization mechanism </span><br><span>  </span><br><span>   private void readObject(ObjectInputStream in){...}  //Compliant, relates to the java serialization mechanism </span><br><span> } </span><br><span>  </span><br><span> Exceptions </span><br><span> This rule doesn&#39;t raise any issue on annotated methods.</span></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>4</span></td></tr><tr><td><span>Synchronized classes Vector, Hashtable, Stack and StringBuffer should not be used</span></td><td><span>Early classes of the Java API, such as Vector, Hashtable and StringBuffer, were synchronized to make them </span><br><span> thread-safe. Unfortunately, synchronization has a big negative impact on performance, even when using these collections from a single thread. </span><br><span> It is better to use their new unsynchronized replacements: </span><br><span>  </span><br><span>    ArrayList or LinkedList instead of Vector  </span><br><span>    Deque instead of Stack  </span><br><span>    HashMap instead of Hashtable  </span><br><span>    StringBuilder instead of StringBuffer  </span><br><span>  </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> Vector cats = new Vector(); </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> ArrayList cats = new ArrayList(); </span><br><span>  </span><br><span> Exceptions </span><br><span> Use of those synchronized classes is ignored in the signatures of overriding methods. </span><br><span>  </span><br><span> @Override </span><br><span> public Vector getCats() {...} </span><br></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>1</span></td></tr><tr><td><span>Empty arrays and collections should be returned instead of null</span></td><td><span>Returning null instead of an actual array or collection forces callers of the method to explicitly test for nullity, making them more </span><br><span> complex and less readable. </span><br><span> Moreover, in many cases, null is used as a synonym for empty. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> public static List</span>&lt;<span>Result</span>&gt;<span> getResults() { </span><br><span>   return null;                             // Noncompliant </span><br><span> } </span><br><span>  </span><br><span> public static Result[] getResults() { </span><br><span>   return null;                             // Noncompliant </span><br><span> } </span><br><span>  </span><br><span> public static void main(String[] args) { </span><br><span>   Result[] results = getResults(); </span><br><span>  </span><br><span>   if (results != null) {                   // Nullity test required to prevent NPE </span><br><span>     for (Result result: results) { </span><br><span>       /* ... </span><em><span>/ </span><br><span>     } </span><br><span>   } </span><br><span> } </span><br><span>  </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> public static List</span>&lt;<span>Result</span>&gt;<span> getResults() { </span><br><span>   return Collections.emptyList();          // Compliant </span><br><span> } </span><br><span>  </span><br><span> public static Result[] getResults() { </span><br><span>   return new Result[0]; </span><br><span> } </span><br><span>  </span><br><span> public static void main(String[] args) { </span><br><span>   for (Result result: getResults()) { </span><br><span>     /</span></em><span> ... */ </span><br><span>   } </span><br><span> } </span><br><span>  </span><br><span> See </span><br><span>  </span><br><span>    CERT, MSC19-C. - For functions that return an array, prefer returning an </span><br><span>   empty array over a null value  </span><br><span>    CERT, MET55-J. - Return an empty array or collection instead of a null </span><br><span>   value for methods that return an array or collection  </span><br></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>3</span></td></tr><tr><td><span>Unused method parameters should be removed</span></td><td><span>Unused parameters are misleading. Whatever the values passed to such parameters, the behavior will be the same. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> void doSomething(int a, int b) {     // &quot;b&quot; is unused </span><br><span>   compute(a); </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> void doSomething(int a) { </span><br><span>   compute(a); </span><br><span> } </span><br><span>  </span><br><span> Exceptions </span><br><span> The rule will not raise issues for unused parameters: </span><br><span>  </span><br><span>    that are annotated with @javax.enterprise.event.Observes  </span><br><span>    in overrides and implementation methods  </span><br><span>    in interface default methods  </span><br><span>    in non-private methods that only throw or that have empty bodies  </span><br><span>    in annotated methods, unless the annotation is @SuppressWarning(&quot;unchecked&quot;) or @SuppressWarning(&quot;rawtypes&quot;), in </span><br><span>   which case the annotation will be ignored  </span><br><span>    in overridable methods (non-final, or not member of a final class, non-static, non-private), if the parameter is documented with a proper </span><br><span>   javadoc.  </span><br><span>  </span><br><span>  </span><br><span> @Override </span><br><span> void doSomething(int a, int b) {     // no issue reported on b </span><br><span>   compute(a); </span><br><span> } </span><br><span>  </span><br><span> public void foo(String s) { </span><br><span>   // designed to be extended but noop in standard case </span><br><span> } </span><br><span>  </span><br><span> protected void bar(String s) { </span><br><span>   //open-closed principle </span><br><span> } </span><br><span>  </span><br><span> public void qix(String s) { </span><br><span>   throw new UnsupportedOperationException(&quot;This method should be implemented in subclasses&quot;); </span><br><span> } </span><br><span>  </span><br><span> /** </span><br><span>  * @param s This string may be use for further computation in overriding classes </span><br><span>  */ </span><br><span> protected void foobar(int a, String s) { // no issue, method is overridable and unused parameter has proper javadoc </span><br><span>   compute(a); </span><br><span> } </span><br><span>  </span><br><span> See </span><br><span>  </span><br><span>    CERT, MSC12-C. - Detect and remove code that has no effect or is never </span><br><span>   executed  </span><br></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>2</span></td></tr><tr><td><span>Sections of code should not be commented out</span></td><td><span>Programmers should not comment out code as it bloats programs and reduces readability. </span><br><span> Unused code should be deleted and can be retrieved from source control history if required.</span></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>71</span></td></tr><tr><td><span>Anonymous inner classes containing only one method should become lambdas</span></td><td><span>Before Java 8, the only way to partially support closures in Java was by using anonymous inner classes. But the syntax of anonymous classes may </span><br><span> seem unwieldy and unclear. </span><br><span> With Java 8, most uses of anonymous inner classes should be replaced by lambdas to highly increase the readability of the source code. </span><br><span> Note that this rule is automatically disabled when the project&#39;s sonar.java.source is lower than 8. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> myCollection.stream().map(new Mapper</span>&lt;<span>String,String</span>&gt;<span>() { </span><br><span>   public String map(String input) { </span><br><span>     return new StringBuilder(input).reverse().toString(); </span><br><span>   } </span><br><span> }); </span><br><span>  </span><br><span> Predicate</span>&lt;<span>String</span>&gt;<span> isEmpty = new Predicate</span>&lt;<span>String</span>&gt;<span> { </span><br><span>     boolean test(String myString) { </span><br><span>         return myString.isEmpty(); </span><br><span>     } </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> myCollection.stream().map(input -</span>&gt;<span> new StringBuilder(input).reverse().toString()); </span><br><span>  </span><br><span> Predicate</span>&lt;<span>String</span>&gt;<span> isEmpty = myString -</span>&gt;<span> myString.isEmpty(); </span><br></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>2</span></td></tr><tr><td><span>Static fields should not be updated in constructors</span></td><td><span>Assigning a value to a static field in a constructor could cause unreliable behavior at runtime since it will change the value for all </span><br><span> instances of the class. </span><br><span> Instead remove the field&#39;s static modifier, or initialize it statically. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> public class Person { </span><br><span>   static Date dateOfBirth; </span><br><span>   static int expectedFingers; </span><br><span>  </span><br><span>   public Person(date birthday) { </span><br><span>     dateOfBirth = birthday;  // Noncompliant; now everyone has this birthday </span><br><span>     expectedFingers = 10;  // Noncompliant </span><br><span>   } </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> public class Person { </span><br><span>   Date dateOfBirth; </span><br><span>   static int expectedFingers = 10; </span><br><span>  </span><br><span>   public Person(date birthday) { </span><br><span>     dateOfBirth = birthday; </span><br><span>   } </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>1</span></td></tr><tr><td><span>String function use should be optimized for single characters</span></td><td><span>An indexOf or lastIndexOf call with a single letter String can be made more performant by switching to a </span><br><span> call with a char argument. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> String myStr = &quot;Hello World&quot;; </span><br><span> // ... </span><br><span> int pos = myStr.indexOf(&quot;W&quot;);  // Noncompliant </span><br><span> // ... </span><br><span> int otherPos = myStr.lastIndexOf(&quot;r&quot;); // Noncompliant </span><br><span> // ... </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> String myStr = &quot;Hello World&quot;; </span><br><span> // ... </span><br><span> int pos = myStr.indexOf(&#39;W&#39;); </span><br><span> // ... </span><br><span> int otherPos = myStr.lastIndexOf(&#39;r&#39;); </span><br><span> // ... </span><br></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>1</span></td></tr><tr><td><span>Printf-style format strings should be used correctly</span></td><td><span>Because printf-style format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that </span><br><span> result in the wrong strings being created. This rule statically validates the correlation of printf-style format strings to their </span><br><span> arguments when calling the format(...) methods of java.util.Formatter, java.lang.String, </span><br><span> java.io.PrintStream, MessageFormat, and java.io.PrintWriter classes and the printf(...) methods of </span><br><span> java.io.PrintStream or java.io.PrintWriter classes.  </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> String.format(&quot;First {0} and then {1}&quot;, &quot;foo&quot;, &quot;bar&quot;);  //Noncompliant. Looks like there is a confusion with the use of {{java.text.MessageFormat}}, parameters &quot;foo&quot; and &quot;bar&quot; will be simply ignored here </span><br><span> String.format(&quot;Display %3</span><span class="MathJax_SVG" tabindex="-1" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.704ex" height="2.107ex" viewBox="0 -784.8 4178 907.3" role="img" focusable="false" style="vertical-align: -0.284ex;"><defs><path stroke-width="0" id="E1-MJMATHI-64" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path><path stroke-width="0" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path><path stroke-width="0" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path stroke-width="0" id="E1-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path><path stroke-width="0" id="E1-MJMATHI-68" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path><path stroke-width="0" id="E1-MJMATHI-65" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#E1-MJMATHI-64" x="0" y="0"></use><use xlink:href="#E1-MJMATHI-61" x="523" y="0"></use><use xlink:href="#E1-MJMATHI-6E" x="1052" y="0"></use><use xlink:href="#E1-MJMATHI-64" x="1652" y="0"></use><use xlink:href="#E1-MJMATHI-74" x="2175" y="0"></use><use xlink:href="#E1-MJMATHI-68" x="2536" y="0"></use><use xlink:href="#E1-MJMATHI-65" x="3112" y="0"></use><use xlink:href="#E1-MJMATHI-6E" x="3578" y="0"></use></g></svg></span><script type="math/tex">d and then %d", 1, 2, 3);   //Noncompliant; the second argument '2' is unused <br /> String.format("Too many arguments %d and %d", 1, 2, 3);  //Noncompliant; the third argument '3' is unused <br /> String.format("First Line\n");   //Noncompliant; %n should be used in place of \n to produce the platform-specific line separator <br /> String.format("Is myObject null ? %b", myObject);   //Noncompliant; when a non-boolean argument is formatted with %b, it prints true for any nonnull value, and false for null. Even if intended, this is misleading. It's better to directly inject the boolean value (myObject == null in this case) <br /> String.format("value is " + value); // Noncompliant <br /> String s = String.format("string without arguments"); // Noncompliant <br />  <br /> MessageFormat.format("Result '{0}'.", value); // Noncompliant; String contains no format specifiers. (quote are discarding format specifiers) <br /> MessageFormat.format("Result {0}.", value, value);  // Noncompliant; 2nd argument is not used <br /> MessageFormat.format("Result {0}.", myObject.toString()); // Noncompliant; no need to call toString() on objects <br />  <br /> java.util.Logger logger; <br /> logger.log(java.util.logging.Level.SEVERE, "Result {0}.", myObject.toString()); // Noncompliant; no need to call toString() on objects <br /> logger.log(java.util.logging.Level.SEVERE, "Result.", new Exception()); // compliant, parameter is an exception <br /> logger.log(java.util.logging.Level.SEVERE, "Result '{0}'", 14); // Noncompliant - String contains no format specifiers. <br /> logger.log(java.util.logging.Level.SEVERE, "Result " + param, exception); // Noncompliant; Lambda should be used to differ string concatenation. <br />  <br /> org.slf4j.Logger slf4jLog; <br /> org.slf4j.Marker marker; <br />  <br /> slf4jLog.debug(marker, "message {}"); <br /> slf4jLog.debug(marker, "message", 1); // Noncompliant - String contains no format specifiers. <br />  <br /> org.apache.logging.log4j.Logger log4jLog; <br /> log4jLog.debug("message", 1); // Noncompliant - String contains no format specifiers. <br />  <br /> Compliant Solution <br />  <br /> String.format("First %s and then %s", "foo", "bar"); <br /> String.format("Display %2</script><span>d and then %d&quot;, 1, 3); </span><br><span> String.format(&quot;Too many arguments %d %d&quot;, 1, 2); </span><br><span> String.format(&quot;First Line%n&quot;); </span><br><span> String.format(&quot;Is myObject null ? %b&quot;, myObject == null); </span><br><span> String.format(&quot;value is %d&quot;, value); </span><br><span> String s = &quot;string without arguments&quot;; </span><br><span>  </span><br><span> MessageFormat.format(&quot;Result {0}.&quot;, value); </span><br><span> MessageFormat.format(&quot;Result &#39;{0}&#39;  =  {0}&quot;, value); </span><br><span> MessageFormat.format(&quot;Result {0}.&quot;, myObject); </span><br><span>  </span><br><span> java.util.Logger logger; </span><br><span> logger.log(java.util.logging.Level.SEVERE, &quot;Result {0}.&quot;, myObject); </span><br><span> logger.log(java.util.logging.Level.SEVERE, &quot;Result {0}&#39;&quot;, 14); </span><br><span> logger.log(java.util.logging.Level.SEVERE, exception, () -</span>&gt;<span> &quot;Result &quot; + param); </span><br><span>  </span><br><span> org.slf4j.Logger slf4jLog; </span><br><span> org.slf4j.Marker marker; </span><br><span>  </span><br><span> slf4jLog.debug(marker, &quot;message {}&quot;); </span><br><span> slf4jLog.debug(marker, &quot;message {}&quot;, 1); </span><br><span>  </span><br><span> org.apache.logging.log4j.Logger log4jLog; </span><br><span> log4jLog.debug(&quot;message {}&quot;, 1); </span><br><span>  </span><br><span> See </span><br><span>  </span><br><span>    CERT, FIO47-C. - Use valid format strings  </span><br></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>2</span></td></tr><tr><td><span>Raw types should not be used</span></td><td><span>Generic types shouldn&#39;t be used raw (without type parameters) in variable declarations or return values. Doing so bypasses generic type checking, </span><br><span> and defers the catch of unsafe code to runtime. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> List myList; // Noncompliant </span><br><span> Set mySet; // Noncompliant </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> List</span>&lt;<span>String</span>&gt;<span> myList; </span><br><span> Set</span>&lt;<span>? extends Number</span>&gt;<span> mySet; </span><br></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>7</span></td></tr><tr><td><span>&quot;java.nio.Files#delete&quot; should be preferred</span></td><td><span>When java.io.File#delete fails, this boolean method simply returns false with no indication of the cause. On </span><br><span> the other hand, when java.nio.file.Files#delete fails, this void method returns one of a series of exception types to better </span><br><span> indicate the cause of the failure. And since more information is generally better in a debugging situation, java.nio.file.Files#delete is </span><br><span> the preferred option. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> public void cleanUp(Path path) { </span><br><span>   File file = new File(path); </span><br><span>   if (!file.delete()) {  // Noncompliant </span><br><span>     //... </span><br><span>   } </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> public void cleanUp(Path path) throws NoSuchFileException, DirectoryNotEmptyException, IOException { </span><br><span>   Files.delete(path); </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>1</span></td></tr><tr><td><span>Assignments should not be redundant</span></td><td><span>The transitive property says that if a == b and b == c, then a == c. In such cases, there&#39;s no point in </span><br><span> assigning a to c or vice versa because they&#39;re already equivalent.  </span><br><span> This rule raises an issue when an assignment is useless because the assigned-to variable already holds the value on all execution paths. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> a = b; </span><br><span> c = a; </span><br><span> b = c; // Noncompliant: c and b are already the same </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> a = b; </span><br><span> c = a; </span><br></td><td><span>CODE_SMELL</span></td><td><span>MAJOR</span></td><td><span>1</span></td></tr><tr><td><span>Method names should comply with a naming convention</span></td><td><span>Shared naming conventions allow teams to collaborate efficiently. This rule checks that all method names match a provided regular expression. </span><br><span> Noncompliant Code Example </span><br><span> With default provided regular expression ^</span>[<span>a-z</span>][a-zA-Z0-9]<span>*$: </span><br><span>  </span><br><span> public int DoSomething(){...} </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> public int doSomething(){...} </span><br><span>  </span><br><span> Exceptions </span><br><span> Overriding methods are excluded.  </span><br><span>  </span><br><span> @Override </span><br><span> public int Do_Something(){...} </span><br></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>7</span></td></tr><tr><td><span>Empty statements should be removed</span></td><td><span>Empty statements, i.e. ;, are usually introduced by mistake, for example because: </span><br><span>  </span><br><span>    It was meant to be replaced by an actual statement, but this was forgotten.  </span><br><span>    There was a typo which lead the semicolon to be doubled, i.e. ;;.  </span><br><span>  </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> void doSomething() { </span><br><span>   ;                                                       // Noncompliant - was used as a kind of TODO marker </span><br><span> } </span><br><span>  </span><br><span> void doSomethingElse() { </span><br><span>   System.out.println(&quot;Hello, world!&quot;);;                     // Noncompliant - double ; </span><br><span>   ... </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> void doSomething() {} </span><br><span>  </span><br><span> void doSomethingElse() { </span><br><span>   System.out.println(&quot;Hello, world!&quot;); </span><br><span>   ... </span><br><span>   for (int i = 0; i </span>&lt;<span> 3; i++) ; // compliant if unique statement of a loop </span><br><span>   ... </span><br><span> } </span><br><span>  </span><br><span> See </span><br><span>  </span><br><span>    CERT, MSC12-C. - Detect and remove code that has no effect or is never </span><br><span>   executed  </span><br><span>    CERT, MSC51-J. - Do not place a semicolon immediately following an if, for, </span><br><span>   or while condition  </span><br><span>    CERT, EXP15-C. - Do not place a semicolon on the same line as an if, for, </span><br><span>   or while statement  </span><br></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>3</span></td></tr><tr><td><span>Return of boolean expressions should not be wrapped into an &quot;if-then-else&quot; statement</span></td><td><span>Return of boolean literal statements wrapped into if-then-else ones should be simplified. </span><br><span> Similarly, method invocations wrapped into if-then-else differing only from boolean literals should be simplified into a single </span><br><span> invocation. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> boolean foo(Object param) { </span><br><span>   if (expression) { // Noncompliant </span><br><span>     bar(param, true, &quot;qix&quot;); </span><br><span>   } else { </span><br><span>     bar(param, false, &quot;qix&quot;); </span><br><span>   } </span><br><span>  </span><br><span>   if (expression) {  // Noncompliant </span><br><span>     return true; </span><br><span>   } else { </span><br><span>     return false; </span><br><span>   } </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> boolean foo(Object param) { </span><br><span>   bar(param, expression, &quot;qix&quot;); </span><br><span>  </span><br><span>   return expression; </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>6</span></td></tr><tr><td><span>Unnecessary imports should be removed</span></td><td><span>The imports part of a file should be handled by the Integrated Development Environment (IDE), not manually by the developer.  </span><br><span> Unused and useless imports should not occur if that is the case.  </span><br><span> Leaving them in reduces the code&#39;s readability, since their presence can be confusing. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> package my.company; </span><br><span>  </span><br><span> import java.lang.String;        // Noncompliant; java.lang classes are always implicitly imported </span><br><span> import my.company.SomeClass;    // Noncompliant; same-package files are always implicitly imported </span><br><span> import java.io.File;            // Noncompliant; File is not used </span><br><span>  </span><br><span> import my.company2.SomeType; </span><br><span> import my.company2.SomeType;    // Noncompliant; &#39;SomeType&#39; is already imported </span><br><span>  </span><br><span> class ExampleClass { </span><br><span>  </span><br><span>   public String someString; </span><br><span>   public SomeType something; </span><br><span>  </span><br><span> } </span><br><span>  </span><br><span> Exceptions </span><br><span> Imports for types mentioned in comments, such as Javadocs, are ignored.</span></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>141</span></td></tr><tr><td><span>&quot;throws&quot; declarations should not be superfluous</span></td><td><span>An exception in a throws declaration in Java is superfluous if it is: </span><br><span>  </span><br><span>    listed multiple times  </span><br><span>    a subclass of another listed exception  </span><br><span>    a RuntimeException, or one of its descendants  </span><br><span>    completely unnecessary because the declared exception type cannot actually be thrown  </span><br><span>  </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> void foo() throws MyException, MyException {}  // Noncompliant; should be listed once </span><br><span> void bar() throws Throwable, Exception {}  // Noncompliant; Exception is a subclass of Throwable </span><br><span> void baz() throws RuntimeException {}  // Noncompliant; RuntimeException can always be thrown </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> void foo() throws MyException {} </span><br><span> void bar() throws Throwable {} </span><br><span> void baz() {} </span><br><span>  </span><br><span> Exceptions </span><br><span> The rule will not raise any issue for exceptions that cannot be thrown from the method body: </span><br><span>  </span><br><span>    in overriding and implementation methods  </span><br><span>    in interface default methods  </span><br><span>    in non-private methods that only throw, have empty bodies, or a single return statement .  </span><br><span>    in overridable methods (non-final, or not member of a final class, non-static, non-private), if the exception is documented with a proper </span><br><span>   javadoc.  </span><br><span>  </span><br><span>  </span><br><span> class A extends B { </span><br><span>   @Override </span><br><span>   void doSomething() throws IOException { </span><br><span>     compute(a); </span><br><span>   } </span><br><span>  </span><br><span>   public void foo() throws IOException {} </span><br><span>  </span><br><span>   protected void bar() throws IOException { </span><br><span>     throw new UnsupportedOperationException(&quot;This method should be implemented in subclasses&quot;); </span><br><span>   } </span><br><span>  </span><br><span>   Object foobar(String s) throws IOException { </span><br><span>     return null; </span><br><span>   } </span><br><span>  </span><br><span>   /** </span><br><span>    * @throws IOException Overriding classes may throw this exception if they print values into a file </span><br><span>    */ </span><br><span>   protected void print() throws IOException { // no issue, method is overridable and the exception has proper javadoc </span><br><span>     System.out.println(&quot;foo&quot;); </span><br><span>   } </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>2</span></td></tr><tr><td><span>Collection.isEmpty() should be used to test for emptiness</span></td><td><span>Using Collection.size() to test for emptiness works, but using Collection.isEmpty() makes the code more readable and can </span><br><span> be more performant. The time complexity of any isEmpty() method implementation should be O(1) whereas some implementations </span><br><span> of size() can be O(n). </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> if (myCollection.size() == 0) {  // Noncompliant </span><br><span>   /* ... </span><em><span>/ </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> if (myCollection.isEmpty()) { </span><br><span>   /</span></em><span> ... */ </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>4</span></td></tr><tr><td><span>Field names should comply with a naming convention</span></td><td><span>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that field </span><br><span> names match a provided regular expression. </span><br><span> Noncompliant Code Example </span><br><span> With the default regular expression ^</span>[<span>a-z</span>][a-zA-Z0-9]<span>*$: </span><br><span>  </span><br><span> class MyClass { </span><br><span>    private int my_field; </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> class MyClass { </span><br><span>    private int myField; </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>5</span></td></tr><tr><td><span>Local variable and method parameter names should comply with a naming convention</span></td><td><span>Shared naming conventions allow teams to collaborate effectively. This rule raises an issue when a local variable or function parameter name does </span><br><span> not match the provided regular expression. </span><br><span> Noncompliant Code Example </span><br><span> With the default regular expression ^</span>[<span>a-z</span>][a-zA-Z0-9]<span>*$: </span><br><span>  </span><br><span> public void doSomething(int my_param) { </span><br><span>   int LOCAL; </span><br><span>   ... </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> public void doSomething(int myParam) { </span><br><span>   int local; </span><br><span>   ... </span><br><span> } </span><br><span>  </span><br><span> Exceptions </span><br><span> Loop counters are ignored by this rule. </span><br><span>  </span><br><span> for (int i_1 = 0; i_1 </span>&lt;<span> limit; i_1++) {  // Compliant </span><br><span>   // ... </span><br><span> } </span><br><span>  </span><br><span> as well as one-character catch variables:  </span><br><span>  </span><br><span> try { </span><br><span> //... </span><br><span> } catch (Exception e) { // Compliant </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>13</span></td></tr><tr><td><span>Overriding methods should do more than simply call the same method in the super class</span></td><td><span>Overriding a method just to call the same method from the super class without performing any other actions is useless and misleading. The only time </span><br><span> this is justified is in final overriding methods, where the effect is to lock in the parent class behavior. This rule ignores such </span><br><span> overrides of equals, hashCode and toString. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> public void doSomething() { </span><br><span>   super.doSomething(); </span><br><span> } </span><br><span>  </span><br><span> @Override </span><br><span> public boolean isLegal(Action action) { </span><br><span>   return super.isLegal(action); </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> @Override </span><br><span> public boolean isLegal(Action action) {         // Compliant - not simply forwarding the call </span><br><span>   return super.isLegal(new Action(/* ... */)); </span><br><span> } </span><br><span>  </span><br><span> @Id </span><br><span> @Override </span><br><span> public int getId() {                            // Compliant - there is annotation different from @Override </span><br><span>   return super.getId(); </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>1</span></td></tr><tr><td><span>Type parameter names should comply with a naming convention</span></td><td><span>Shared naming conventions make it possible for a team to collaborate efficiently. Following the established convention of single-letter type </span><br><span> parameter names helps users and maintainers of your code quickly see the difference between a type parameter and a poorly named class. </span><br><span> This rule check that all type parameter names match a provided regular expression. The following code snippets use the default regular </span><br><span> expression. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> public class MyClass</span>&lt;<span>TYPE</span>&gt;<span> { // Noncompliant </span><br><span>   </span>&lt;<span>TYPE</span>&gt;<span> void method(TYPE t) { // Noncompliant </span><br><span>   } </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> public class MyClass</span>&lt;<span>T</span>&gt;<span> { </span><br><span>   </span>&lt;<span>T</span>&gt;<span> void method(T t) { </span><br><span>   } </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>2</span></td></tr><tr><td><span>Array designators &quot;[]&quot; should be on the type, not the variable</span></td><td><span>Array designators should always be located on the type for better code readability. Otherwise, developers must look both at the type and the </span><br><span> variable name to know whether or not a variable is an array. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> int matrix</span>[][]<span>;   // Noncompliant </span><br><span> int[] matrix[];   // Noncompliant </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> int</span>[][]<span> matrix;   // Compliant </span><br></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>1</span></td></tr><tr><td><span>Package names should comply with a naming convention</span></td><td><span>Shared coding conventions allow teams to collaborate efficiently. This rule checks that all package names match a provided regular expression. </span><br><span> Noncompliant Code Example </span><br><span> With the default regular expression ^[a-z</span><em><span>]+(</span><span>.</span><span>[a-z</span></em><span>][a-z0-9_]</span><em><span>)</span></em><span>$: </span><br><span>  </span><br><span> package org.exAmple; // Noncompliant </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> package org.example; </span><br></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>30</span></td></tr><tr><td><span>Loops should not contain more than a single &quot;break&quot; or &quot;continue&quot; statement</span></td><td><span>Restricting the number of break and continue statements in a loop is done in the interest of good structured programming. </span><br><span>  </span><br><span> One break and continue statement is acceptable in a loop, since it facilitates optimal coding. If there is more than one, </span><br><span> the code should be refactored to increase readability. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> for (int i = 1; i </span>&lt;<span>= 10; i++) {     // Noncompliant - 2 continue - one might be tempted to add some logic in between </span><br><span>   if (i % 2 == 0) { </span><br><span>     continue; </span><br><span>   } </span><br><span>  </span><br><span>   if (i % 3 == 0) { </span><br><span>     continue; </span><br><span>   } </span><br><span>  </span><br><span>   System.out.println(&quot;i = &quot; + i); </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>1</span></td></tr><tr><td><span>Private fields only used as local variables in methods should become local variables</span></td><td><span>When the value of a private field is always assigned to in a class&#39; methods before being read, then it is not being used to store class </span><br><span> information. Therefore, it should become a local variable in the relevant methods to prevent any misunderstanding. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> public class Foo { </span><br><span>   private int a; </span><br><span>   private int b; </span><br><span>  </span><br><span>   public void doSomething(int y) { </span><br><span>     a = y + 5; </span><br><span>     ... </span><br><span>     if(a == 0) { </span><br><span>       ... </span><br><span>     } </span><br><span>     ... </span><br><span>   } </span><br><span>  </span><br><span>   public void doSomethingElse(int y) { </span><br><span>     b = y + 3; </span><br><span>     ... </span><br><span>   } </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> public class Foo { </span><br><span>  </span><br><span>   public void doSomething(int y) { </span><br><span>     int a = y + 5; </span><br><span>     ... </span><br><span>     if(a == 0) { </span><br><span>       ... </span><br><span>     } </span><br><span>   } </span><br><span>  </span><br><span>   public void doSomethingElse(int y) { </span><br><span>     int b = y + 3; </span><br><span>     ... </span><br><span>   } </span><br><span> } </span><br><span>  </span><br><span> Exceptions </span><br><span> This rule doesn&#39;t raise any issue on annotated field.</span></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>2</span></td></tr><tr><td><span>Local variables should not be declared and then immediately returned or thrown</span></td><td><span>Declaring a variable only to immediately return or throw it is a bad practice. </span><br><span> Some developers argue that the practice improves code readability, because it enables them to explicitly name what is being returned. However, this </span><br><span> variable is an internal implementation detail that is not exposed to the callers of the method. The method name should be sufficient for callers to </span><br><span> know exactly what will be returned. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> public long computeDurationInMilliseconds() { </span><br><span>   long duration = (((hours * 60) + minutes) * 60 + seconds ) * 1000 ; </span><br><span>   return duration; </span><br><span> } </span><br><span>  </span><br><span> public void doSomething() { </span><br><span>   RuntimeException myException = new RuntimeException(); </span><br><span>   throw myException; </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> public long computeDurationInMilliseconds() { </span><br><span>   return (((hours * 60) + minutes) * 60 + seconds ) * 1000 ; </span><br><span> } </span><br><span>  </span><br><span> public void doSomething() { </span><br><span>   throw new RuntimeException(); </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>2</span></td></tr><tr><td><span>Multiple variables should not be declared on the same line</span></td><td><span>Declaring multiple variables on one line is difficult to read. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> class MyClass { </span><br><span>  </span><br><span>   private int a, b; </span><br><span>  </span><br><span>   public void method(){ </span><br><span>     int c; int d; </span><br><span>   } </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> class MyClass { </span><br><span>  </span><br><span>   private int a; </span><br><span>   private int b; </span><br><span>  </span><br><span>   public void method(){ </span><br><span>     int c; </span><br><span>     int d; </span><br><span>   } </span><br><span> } </span><br><span>  </span><br><span> See </span><br><span>  </span><br><span>    CERT, DCL52-J. - Do not declare more than one variable per declaration </span><br><span>    </span><br><span>    CERT, DCL04-C. - Do not declare more than one variable per declaration  </span><br></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>1</span></td></tr><tr><td><span>Classes should not be empty</span></td><td><span>There is no good excuse for an empty class. If it&#39;s being used simply as a common extension point, it should be replaced with an </span><br><span> interface. If it was stubbed in as a placeholder for future development it should be fleshed-out. In any other case, it should be </span><br><span> eliminated. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> public class Nothing {  // Noncompliant </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> public interface Nothing { </span><br><span> } </span><br><span>  </span><br><span> Exceptions </span><br><span> Empty classes can be used as marker types (for Spring for instance), therefore empty classes that are annotated will be ignored. </span><br><span>  </span><br><span> @Configuration </span><br><span> @EnableWebMvc </span><br><span> public final class ApplicationConfiguration { </span><br><span>  </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>1</span></td></tr><tr><td><span>Methods of &quot;Random&quot; that return floating point values should not be used in random integer generation</span></td><td><span>There is no need to multiply the output of Random&#39;s nextDouble method to get a random integer. Use the </span><br><span> nextInt method instead. </span><br><span> This rule raises an issue when the return value of any of Random&#39;s methods that return a floating point value is converted to an </span><br><span> integer. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> Random r = new Random(); </span><br><span> int rand = (int)r.nextDouble() * 50;  // Noncompliant way to get a pseudo-random value between 0 and 50 </span><br><span> int rand2 = (int)r.nextFloat(); // Noncompliant; will always be 0; </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> Random r = new Random(); </span><br><span> int rand = r.nextInt(50);  // returns pseudo-random value between 0 and 50 </span><br></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>1</span></td></tr><tr><td><span>The diamond operator (&quot;&lt;&gt;&quot;) should be used</span></td><td><span>Java 7 introduced the diamond operator (</span>&lt;&gt;<span>) to reduce the verbosity of generics code. For instance, instead of having to declare </span><br><span> a List&#39;s type in both its declaration and its constructor, you can now simplify the constructor declaration with </span>&lt;&gt;<span>, </span><br><span> and the compiler will infer the type. </span><br><span> Note that this rule is automatically disabled when the project&#39;s sonar.java.source is lower than 7. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> List</span>&lt;<span>String</span>&gt;<span> strings = new ArrayList</span>&lt;<span>String</span>&gt;<span>();  // Noncompliant </span><br><span> Map</span>&lt;<span>String,List</span>&lt;<span>Integer</span>&gt;&gt;<span> map = new HashMap</span>&lt;<span>String,List</span>&lt;<span>Integer</span>&gt;&gt;<span>();  // Noncompliant </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> List</span>&lt;<span>String</span>&gt;<span> strings = new ArrayList</span>&lt;&gt;<span>(); </span><br><span> Map</span>&lt;<span>String,List</span>&lt;<span>Integer</span>&gt;&gt;<span> map = new HashMap</span>&lt;&gt;<span>(); </span><br></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>9</span></td></tr><tr><td><span>Nested &quot;enum&quot;s should not be declared static</span></td><td><span>According to the docs: </span><br><span>  </span><br><span>   Nested enum types are implicitly </span><br><span>   static. </span><br><span>  </span><br><span> So there&#39;s no need to declare them static explicitly. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> public class Flower { </span><br><span>   static enum Color { // Noncompliant; static is redundant here </span><br><span>     RED, YELLOW, BLUE, ORANGE </span><br><span>   } </span><br><span>  </span><br><span>   // ... </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> public class Flower { </span><br><span>   enum Color { // Compliant </span><br><span>     RED, YELLOW, BLUE, ORANGE </span><br><span>   } </span><br><span>  </span><br><span>   // ... </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>1</span></td></tr><tr><td><span>Arrays should not be copied using loops</span></td><td><span>Using a loop to copy an array or a subset of an array is simply wasted code when there are built-in functions to do it for you. Instead, use </span><br><span> Arrays.copyOf to copy an entire array into another array, use System.arraycopy to copy only a subset of an array into </span><br><span> another array, and use Arrays.asList to feed the constructor of a new list with an array. </span><br><span> Note that Arrays.asList simply puts a Collections wrapper around the original array, so further steps are required if a </span><br><span> non-fixed-size List is desired. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> public void makeCopies(String[] source) { </span><br><span>  </span><br><span>   this.array = new String[source.length]; </span><br><span>   this.list = new ArrayList(source.length); </span><br><span>  </span><br><span>   for (int i = 0; i </span>&lt;<span> source.length; i++) { </span><br><span>     this.array[i] = source[i]; // Noncompliant </span><br><span>   } </span><br><span>  </span><br><span>   for (String s : source) { </span><br><span>     this.list.add(s); // Noncompliant </span><br><span>   } </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> public void makeCopies(String[] source) { </span><br><span>   this.array = Arrays.copyOf(source, source.length); </span><br><span>   Collections.addAll(this.list, source); </span><br><span> } </span><br><span>  </span><br><span> Exceptions </span><br><span> Rule detects only the most idiomatic patterns, it will not consider loops with non-trivial control flow. For example, array elements that are </span><br><span> copied conditionally are ignored. </span><br><span>  </span><br><span> public int[] getCopy(int[] source) { </span><br><span>   int[] dest = new int[source.length]; </span><br><span>   for (int i = 0; i </span>&lt;<span> source.length; i++) { </span><br><span>     if (source[i] </span>&gt;<span> 10) { </span><br><span>       dest[i] = source[i];  // Compliant </span><br><span>     } </span><br><span>   } </span><br><span>   return dest; </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>1</span></td></tr><tr><td><span>Jump statements should not be redundant</span></td><td><span>Jump statements such as return and continue let you change the default flow of program execution, but jump statements </span><br><span> that direct the control flow to the original direction are just a waste of keystrokes. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> public void foo() { </span><br><span>   while (condition1) { </span><br><span>     if (condition2) { </span><br><span>       continue; // Noncompliant </span><br><span>     } else { </span><br><span>       doTheThing(); </span><br><span>     } </span><br><span>   } </span><br><span>   return; // Noncompliant; this is a void method </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> public void foo() { </span><br><span>   while (condition1) { </span><br><span>     if (!condition2) { </span><br><span>       doTheThing(); </span><br><span>     } </span><br><span>   } </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>37</span></td></tr><tr><td><span>Arrays should not be created for varargs parameters</span></td><td><span>There&#39;s no point in creating an array solely for the purpose of passing it as a varargs (...) argument; varargs is an array. </span><br><span> Simply pass the elements directly. They will be consolidated into an array automatically. Incidentally passing an array where Object ... </span><br><span> is expected makes the intent ambiguous: Is the array supposed to be one object or a collection of objects? </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> public void callTheThing() { </span><br><span>   //... </span><br><span>   doTheThing(new String[] { &quot;s1&quot;, &quot;s2&quot;});  // Noncompliant: unnecessary </span><br><span>   doTheThing(new String[12]);  // Compliant </span><br><span>   doTheOtherThing(new String[8]);  // Noncompliant: ambiguous </span><br><span>   // ... </span><br><span> } </span><br><span>  </span><br><span> public void doTheThing (String ... args) { </span><br><span>   // ... </span><br><span> } </span><br><span>  </span><br><span> public void doTheOtherThing(Object ... args) { </span><br><span>   // ... </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> public void callTheThing() { </span><br><span>   //... </span><br><span>   doTheThing(&quot;s1&quot;, &quot;s2&quot;); </span><br><span>   doTheThing(new String[12]); </span><br><span>   doTheOtherThing((Object[]) new String[8]); </span><br><span>    // ... </span><br><span> } </span><br><span>  </span><br><span> public void doTheThing (String ... args) { </span><br><span>   // ... </span><br><span> } </span><br><span>  </span><br><span> public void doTheOtherThing(Object ... args) { </span><br><span>   // ... </span><br><span> } </span><br></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>3</span></td></tr><tr><td><span>Boxed &quot;Boolean&quot; should be avoided in boolean expressions</span></td><td><span>When boxed type java.lang.Boolean is used as an expression it will throw NullPointerException if the value is </span><br><span> null as defined in Java Language Specification 5.1.8 </span><br><span> Unboxing Conversion. </span><br><span> It is safer to avoid such conversion altogether and handle the null value explicitly. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> Boolean b = getBoolean(); </span><br><span> if (b) {  // Noncompliant, it will throw NPE when b == null </span><br><span>   foo(); </span><br><span> } else { </span><br><span>   bar(); </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> Boolean b = getBoolean(); </span><br><span> if (Boolean.TRUE.equals(b)) { </span><br><span>   foo(); </span><br><span> } else { </span><br><span>   bar();  // will be invoked for both b == false and b == null </span><br><span> } </span><br><span>  </span><br><span> See </span><br><span>  * Java Language Specification 5.1.8 Unboxing Conversion</span></td><td><span>CODE_SMELL</span></td><td><span>MINOR</span></td><td><span>4</span></td></tr><tr><td><span>Throwable.printStackTrace(...) should not be called</span></td><td><span>Throwable.printStackTrace(...) prints a Throwable and its stack trace to some stream. By default that stream </span><br><span> System.Err, which could inadvertently expose sensitive information. </span><br><span> Loggers should be used instead to print Throwables, as they have many advantages: </span><br><span>  </span><br><span>    Users are able to easily retrieve the logs.  </span><br><span>    The format of log messages is uniform and allow users to browse the logs easily.  </span><br><span>  </span><br><span> This rule raises an issue when printStackTrace is used without arguments, i.e. when the stack trace is printed to the default </span><br><span> stream. </span><br><span> Noncompliant Code Example </span><br><span>  </span><br><span> try { </span><br><span>   /* ... </span><em><span>/ </span><br><span> } catch(Exception e) { </span><br><span>   e.printStackTrace();        // Noncompliant </span><br><span> } </span><br><span>  </span><br><span> Compliant Solution </span><br><span>  </span><br><span> try { </span><br><span>   /</span></em><span> ... */ </span><br><span> } catch(Exception e) { </span><br><span>   LOGGER.log(&quot;context&quot;, e); </span><br><span> } </span><br><span>  </span><br><span> See </span><br><span>  </span><br><span>    OWASP Top 10 2017 Category A3 - Sensitive Data Exposure </span><br><span>    </span><br><span>    MITRE, CWE-489 - Leftover Debug Code  </span><br></td><td><span>VULNERABILITY</span></td><td><span>MINOR</span></td><td><span>11</span></td></tr></tbody></table></figure></div>
</body>
</html>